{"FtsoRegistry":[{"method":"addFtso","natSpec":{"return":[],"notice":"Update current active FTSO contracts mapping","param":{"_ftsoContract":"new target FTSO contract"}}},{"method":"removeFtso","natSpec":{"return":[],"dec":"Reverts if the provided index is unsupported","param":{"_ftso":"ftso to remove"}}},{"method":"getFtso","natSpec":{"return":[["_activeFtso"," FTSO contract for provided index"]],"dec":"Reverts if unsupported index is passed"}},{"method":"getFtsoBySymbol","natSpec":{"return":[["_activeFtso"," FTSO contract for provided symbol"]],"dec":"Reverts if unsupported symbol is passed"}},{"method":"getCurrentPrice","natSpec":{"return":[["_price"," current price of asset in USD"],["_timestamp"," timestamp for when this price was updated"]],"notice":"Public view function to get the price of active FTSO for given asset index","dec":"Reverts if unsupported index is passed"}},{"method":"getSupportedIndices","natSpec":{"return":[["_supportedIndices"," the array of all active FTSO indices in increasing order. \nActive FTSOs are ones that currently receive price feeds."]]}},{"method":"getSupportedSymbols","natSpec":{"return":[["_supportedSymbols"," the array of all active FTSO symbols in increasing order. \nActive FTSOs are ones that currently receive price feeds."]]}},{"method":"getSupportedIndicesAndFtsos","natSpec":{"return":[["_supportedIndices"," the array of all supported indices"],["_ftsos"," the array of all supported ftsos"]],"notice":"Get array of all supported indices and corresponding FTSOs"}},{"method":"getSupportedSymbolsAndFtsos","natSpec":{"return":[["_supportedSymbols"," the array of all supported symbols"],["_ftsos"," the array of all supported ftsos"]],"notice":"Get array of all supported symbols and corresponding FTSOs"}},{"method":"getSupportedIndicesAndSymbols","natSpec":{"return":[["_supportedIndices"," the array of all supported indices"],["_supportedSymbols"," the array of all supported symbols"]],"notice":"Get array of all supported indices and corresponding symbols"}},{"method":"getSupportedIndicesSymbolsAndFtsos","natSpec":{"return":[["_supportedIndices"," the array of all supported indices"],["_supportedSymbols"," the array of all supported symbols"],["_ftsos"," the array of all supported ftsos"]],"notice":"Get array of all supported indices, corresponding symbols and FTSOs"}},{"method":"getSupportedFtsos","natSpec":{"return":[["_ftsos"," the array of all supported FTSOs"]],"notice":"Get array of all FTSO contracts for all supported asset indices. \nThe index of FTSO in returned array does not necessarily correspond to _assetIndex\nDue to deletion, some indices might be unsupported.","dec":"See `getSupportedIndicesAndFtsos` for pair of correct indices and `getAllFtsos` \nfor FTSOs at valid indices but with possible \"null\" holes."}},{"method":"getFtsos","natSpec":{"return":[["_ftsos"," the array of FTSOs"]],"notice":"Get the active FTSOs for given indices"}},{"method":"getAllFtsos","natSpec":{"return":[["_ftsos"," the array of all FTSOs"]],"notice":"Get array of all FTSO contracts for all supported asset indices","dec":"Return value might contain uninitialized FTSOS at zero address."}},{"method":"getFtsoHistory","natSpec":{"return":[["_ftsoAddressHistory"," the history of FTSOs contract for provided index"]],"notice":"Get the history of FTSOs for given index","dec":"If there are less then MAX_HISTORY_LENGTH the remaining addresses will be 0 addresses","param":{"_assetIndex":"asset index"}}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method."}},{"method":"_shiftHistory","natSpec":{"return":[],"notice":"Shift the FTSOs history by one so the FTSO at index 0 can be overwritten","dec":"Internal helper function"}},{"method":"_getFtso","natSpec":{"return":[],"notice":"Get the active FTSO for given index","dec":"Internal get ftso function so it can be used within other methods"}}],"VoterWhitelister":[{"method":"requestFullVoterWhitelisting","natSpec":{"return":[]}},{"method":"requestWhitelistingVoter","natSpec":{"return":[]}},{"method":"setMaxVotersForFtso","natSpec":{"return":[]}},{"method":"setDefaultMaxVotersForFtso","natSpec":{"return":[]}},{"method":"addFtso","natSpec":{"return":[]}},{"method":"removeFtso","natSpec":{"return":[]}},{"method":"removeTrustedAddressFromWhitelist","natSpec":{"return":[]}},{"method":"getFtsoWhitelistedPriceProvidersBySymbol","natSpec":{"return":[]}},{"method":"getFtsoWhitelistedPriceProviders","natSpec":{"return":[]}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method."}},{"method":"_requestWhitelistingVoter","natSpec":{"return":[]}},{"method":"_minVotePowerIndex","natSpec":{"return":[]}},{"method":"_getVotePowerWeights","natSpec":{"return":[]}},{"method":"_getNativeVotePowerWeights","natSpec":{"return":[]}},{"method":"_getAssetVotePowerWeights","natSpec":{"return":[]}},{"method":"_getVotePowers","natSpec":{"return":[]}},{"method":"_isTrustedAddress","natSpec":{"return":[]}},{"method":"_voterWhitelisted","natSpec":{"return":[]}},{"method":"_votersRemovedFromWhitelist","natSpec":{"return":[]}},{"method":"_arraySum","natSpec":{"return":[]}},{"method":"_computeWeightedSum","natSpec":{"return":[]}},{"method":"_findMinimum","natSpec":{"return":[]}}],"ValidatorRegistry":[{"method":"registerDataProvider","natSpec":{"return":[],"notice":"Register data provider's address as a validator - emits DataProviderRegistered event","param":{"_pChainPublicKey":"Data provider's P-Chain public key"},"dec":"_nodeId and `_pChainPublicKey` should not be already in use by some other data provider"}},{"method":"unregisterDataProvider","natSpec":{"return":[],"notice":"Unregister data provider's address as a validator - emits DataProviderUnregistered event"}},{"method":"getDataProviderInfo","natSpec":{"return":[["_nodeId"," Data provider's node id"],["_pChainPublicKey"," Data provider's P-Chain public key"]],"notice":"Returns data provider's node id and P-Chain public key","param":{"_dataProvider":"Data provider's address"}}},{"method":"getDataProviderForNodeId","natSpec":{"return":[["_dataProvider"," Data provider's address"]],"notice":"Returns data provider's address that was registered with given node id","param":{"_nodeId":"Data provider's node id hash"}}},{"method":"getDataProviderForPChainPublicKey","natSpec":{"return":[["_dataProvider"," Data provider's address"]],"notice":"Returns data provider's address that was registered with given P-Chain public key","param":{"_pChainPublicKey":"Data provider's P-Chain public key hash"}}}],"Ftso":[{"method":"revealPriceSubmitter","natSpec":{"return":[],"notice":"Emits PriceRevealed event","param":{"_price":"Submitted price in USD"}}},{"method":"finalizePriceEpoch","natSpec":{"return":[["_eligibleAddresses"," List of addresses eligible for reward"],["_natWeights"," List of native token weights corresponding to the eligible addresses"],["_natWeightsSum"," Sum of weights in _natWeights"]],"notice":"Computes epoch price based on gathered votes","param":{"_returnRewardData":"Parameter that determines if the reward data is returned"}}},{"method":"fallbackFinalizePriceEpoch","natSpec":{"return":[],"notice":"Forces finalization of price epoch calculating median price from trusted addresses","param":{"_epochId":"Id of the epoch to finalize"},"dec":"Used as a fallback method if epoch finalization is failing"}},{"method":"forceFinalizePriceEpoch","natSpec":{"return":[],"notice":"Forces finalization of price epoch - only called when exception happened","param":{"_epochId":"Id of the epoch to finalize"},"dec":"Used as a fallback method if epoch finalization is failing"}},{"method":"activateFtso","natSpec":{"return":[],"notice":"Initializes ftso immutable settings and activates oracle","param":{"_revealPeriodSeconds":"Duration of epoch reveal period in seconds"}}},{"method":"deactivateFtso","natSpec":{"return":[],"notice":"Deactivates oracle"}},{"method":"updateInitialPrice","natSpec":{"return":[]}},{"method":"configureEpochs","natSpec":{"return":[],"notice":"Sets configurable settings related to epochs","param":{"_trustedAddresses":"trusted addresses - use their prices if low nat turnout is not achieved"},"dec":"Should never revert if called from ftso manager"}},{"method":"setVotePowerBlock","natSpec":{"return":[],"notice":"Sets current vote power block","param":{"_votePowerBlock":"Vote power block"}}},{"method":"setAsset","natSpec":{"return":[],"notice":"Sets asset for FTSO to operate as single-asset oracle","param":{"_asset":"Asset"}}},{"method":"setAssetFtsos","natSpec":{"return":[],"notice":"Sets an array of FTSOs for FTSO to operate as multi-asset oracle","param":{"_assetFtsos":"Array of FTSOs"},"dec":"FTSOs implicitly determine the FTSO assets"}},{"method":"initializeCurrentEpochStateForReveal","natSpec":{"return":[],"notice":"Initializes current epoch instance for reveal","param":{"_fallbackMode":"Current epoch in fallback mode"}}},{"method":"getPriceEpochConfiguration","natSpec":{"return":[["_firstEpochStartTs"," First epoch start timestamp"],["_submitPeriodSeconds"," Submit period in seconds"],["_revealPeriodSeconds"," Reveal period in seconds"]],"notice":"Returns current epoch data"}},{"method":"epochsConfiguration","natSpec":{"return":[],"notice":"Returns current configuration of epoch state"}},{"method":"getAsset","natSpec":{"return":[],"notice":"Returns the FTSO asset","dec":"asset is null in case of multi-asset FTSO"}},{"method":"getAssetFtsos","natSpec":{"return":[],"notice":"Returns the asset FTSOs","dec":"AssetFtsos is not null only in case of multi-asset FTSO"}},{"method":"getCurrentPrice","natSpec":{"return":[["_price"," Price in USD multiplied by ASSET_PRICE_USD_DECIMALS"],["_timestamp"," Time when price was updated for the last time"]],"notice":"Returns current asset price"}},{"method":"getCurrentPriceFromTrustedProviders","natSpec":{"return":[["_price"," Price in USD multiplied by ASSET_PRICE_USD_DECIMALS"],["_timestamp"," Time when price was updated for the last time"]],"notice":"Returns current asset price calculated from trusted providers"}},{"method":"getCurrentPriceDetails","natSpec":{"return":[["_price"," Price in USD multiplied by ASSET_PRICE_USD_DECIMALS"],["_priceTimestamp"," Time when price was updated for the last time"],["_priceFinalizationType"," Finalization type when price was updated for the last time"],["_lastPriceEpochFinalizationTimestamp"," Time when last price epoch was finalized"],["_lastPriceEpochFinalizationType"," Finalization type of last finalized price epoch"]],"notice":"Returns current asset price details"}},{"method":"getEpochPrice","natSpec":{"return":[["Price"," in USD multiplied by ASSET_PRICE_USD_DECIMALS"]],"notice":"Returns asset price consented in specific epoch","param":{"_epochId":"Id of the epoch"}}},{"method":"getEpochPriceForVoter","natSpec":{"return":[["Price"," in USD multiplied by ASSET_PRICE_USD_DECIMALS"]],"notice":"Returns asset price submitted by voter in specific epoch","param":{"_voter":"Address of the voter"}}},{"method":"getCurrentRandom","natSpec":{"return":[["Random"," number"]],"notice":"Returns current random number","dec":"Should never revert"}},{"method":"getRandom","natSpec":{"return":[["Random"," number"]],"notice":"Returns random number of the specified epoch","param":{"_epochId":"Id of the epoch"}}},{"method":"getPriceEpochData","natSpec":{"return":[["_epochId"," Current epoch id"],["_epochSubmitEndTime"," End time of the current epoch price submission as seconds from unix epoch"],["_epochRevealEndTime"," End time of the current epoch price reveal as seconds from unix epoch"],["_votePowerBlock"," Vote power block for the current epoch"],["_fallbackMode"," Current epoch in fallback mode - only votes from trusted addresses will be used"]],"notice":"Returns current epoch data","dec":"half-closed intervals - end time not included"}},{"method":"getVoteWeightingParameters","natSpec":{"return":[["_assets"," the list of assets that are accounted in vote"],["_assetMultipliers"," weight multiplier of each asset in (multiasset) ftso"],["_totalVotePowerNat"," total native token vote power at block"],["_totalVotePowerAsset"," total combined asset vote power at block"],["_assetWeightRatio"," ratio of combined asset vp vs. native token vp (in BIPS)"],["_votePowerBlock"," vote powewr block for given epoch"]],"notice":"Returns parameters necessary for replicating vote weighting (used in VoterWhitelister)."}},{"method":"wNatVotePowerCached","natSpec":{"return":[],"notice":"Returns wNat vote power for the specified owner and the given epoch id","param":{"_epochId":"Id of the epoch"}}},{"method":"getCurrentEpochId","natSpec":{"return":[],"notice":"Returns current epoch id","dec":"Should never revert"}},{"method":"getEpochId","natSpec":{"return":[],"notice":"Returns id of the epoch which was opened for price submission at the specified timestamp","param":{"_timestamp":"Timestamp as seconds from unix epoch"},"dec":"Should never revert"}},{"method":"_revealPrice","natSpec":{"return":[],"notice":"Emits PriceRevealed event","param":{"_price":"Submitted price in USD"}}},{"method":"_getAssetData","natSpec":{"return":[["_assets"," List of assets"],["_votePowers"," List of vote powers"],["_prices"," List of asset prices"]],"notice":"Returns the list of assets and its vote powers"}},{"method":"_refreshAssets","natSpec":{"return":[],"notice":"Refreshes epoch state assets if FTSO is in multi-asset mode","dec":"Assets are determined by other single-asset FTSOs on which the asset may change at any time"}},{"method":"_medianFinalizePriceEpoch","natSpec":{"return":[],"notice":"Forces finalization of the epoch calculating median price from trusted addresses","param":{"_exception":"Indicates if the exception happened"},"dec":"Sets the price to be the median of prices from trusted addresses or force finalize if no votes submitted"}},{"method":"_forceFinalizePriceEpoch","natSpec":{"return":[],"notice":"Forces finalization of the epoch","param":{"_exception":"Indicates if the exception happened"},"dec":"Sets the median price to be equal to the price from the previous epoch (if epoch id is 0, price is 0)"}},{"method":"_writeEpochPriceData","natSpec":{"return":[],"notice":"Stores epoch data related to price\nTo be implemented in descendants"}},{"method":"_writeFallbackEpochPriceData","natSpec":{"return":[],"notice":"Stores epoch data related to price (fallback / low turnout / forced mode)\nTo be implemented in descendants"}},{"method":"_getVotePowerOf","natSpec":{"return":[],"notice":"Returns native token and asset vote power for epoch - returns (0, 0) if in fallback mode","param":{"_voterWNatVP":"Voter nat vote power as queried by price submitter"},"dec":"Checks if vote power is sufficient and adjusts vote power if it is too large"}},{"method":"_getVotePowerAt","natSpec":{"return":[],"notice":"Returns vote power of the given token at the specified block","param":{"_vpBlock":"Vote power block"},"dec":"Returns 0 if vote power token is null"}},{"method":"_getVotePowerOfAt","natSpec":{"return":[],"notice":"Returns vote power of the given token at the specified block and for the specified owner","param":{"_vpBlock":"Vote power block"},"dec":"Returns 0 if vote power token is null"}},{"method":"_getRandom","natSpec":{"return":[],"notice":"Returns random for given epoch id"}},{"method":"_readVotes","natSpec":{"return":[],"notice":"Extract vote data from epoch","param":{"_epoch":"Epoch instance"}}},{"method":"_readRewardData","natSpec":{"return":[],"notice":"Extracts reward data for epoch","param":{"_weightNat":"Array of native token weights"}}},{"method":"_getEpochForFinalization","natSpec":{"return":[["_epoch"," Return epoch instance"]],"notice":"Get epoch instance for given epoch id and check if it can be finished","param":{"_epochId":"Epoch id"}}},{"method":"_getEpochInstance","natSpec":{"return":[],"notice":"Return epoch instance if epoch id exists in storage, reverts if it is already overwritten","param":{"_epochId":"Epoch id"}}},{"method":"_getEpochId","natSpec":{"return":[["Epoch"," id"]],"notice":"Returns the id of the epoch opened for price submission at the given timestamp","param":{"_timestamp":"Timestamp as seconds since unix epoch"},"dec":"Should never revert"}},{"method":"_getEpochSubmitStartTime","natSpec":{"return":[["Timestamp"," as seconds since unix epoch"]],"notice":"Returns start time of price submission for an epoch instance","param":{"_epochId":"Id of epoch instance"}}},{"method":"_getEpochSubmitEndTime","natSpec":{"return":[["Timestamp"," as seconds since unix epoch"]],"notice":"Returns end time of price submission for an epoch instance = reveal start time","param":{"_epochId":"Id of epoch instance"},"dec":"half-closed interval - end time not included"}},{"method":"_getEpochRevealEndTime","natSpec":{"return":[["Timestamp"," as seconds since unix epoch"]],"notice":"Returns end time of price reveal for an epoch instance","param":{"_epochId":"Id of epoch instance"},"dec":"half-closed interval - end time not included"}},{"method":"_isEpochRevealInProcess","natSpec":{"return":[["True"," if epoch reveal is in process and false otherwise"]],"notice":"Determines if the epoch with the given id is currently in the reveal process","param":{"_epochId":"Id of epoch"}}},{"method":"_isAddressEligible","natSpec":{"return":[["_eligible"," Return True if the address should be rewarded"]],"notice":"Checks if an address is eligible for reward (for edge quartile cases)","param":{"_address":"Address that submitted the price"}}}],"FtsoManager":[{"method":"setInitialRewardData","natSpec":{"return":[],"notice":"Set reward data to values from old ftso manager","dec":"Can be called only before activation"}},{"method":"activate","natSpec":{"return":[],"notice":"Activates FTSO manager (daemonize() runs jobs)"}},{"method":"daemonize","natSpec":{"return":[],"notice":"Runs task triggered by Daemon.\nThe tasks include the following by priority\n- finalizePriceEpoch     \n- Set governance parameters and initialize epochs\n- finalizeRewardEpoch"}},{"method":"switchToFallbackMode","natSpec":{"return":[],"notice":"Called if out of gas or any other unknown error occures in flare daemonize call"}},{"method":"addFtso","natSpec":{"return":[],"notice":"Adds FTSO to the list of rewarded FTSOs\nAll ftsos in multi asset ftso must be managed by this ftso manager"}},{"method":"addFtsosBulk","natSpec":{"return":[],"notice":"Adds FTSO list to the list of rewarded FTSOs\nAll ftsos in multi asset ftso must be managed by this ftso manager"}},{"method":"removeFtso","natSpec":{"return":[],"notice":"Removes FTSO from the list of the rewarded FTSOs - revert if ftso is used in multi asset ftso","dec":"Deactivates _ftso"}},{"method":"replaceFtso","natSpec":{"return":[],"notice":"Replaces one ftso with another\nAll ftsos in multi asset ftso must be managed by this ftso manager","dec":"Deactivates old ftso"}},{"method":"replaceFtsosBulk","natSpec":{"return":[],"notice":"Bulk replaces one ftso with another\nAll ftsos in multi asset ftso must be managed by this ftso manager","dec":"Deactivates old ftsos"}},{"method":"deactivateFtsos","natSpec":{"return":[],"notice":"Deactivates ftsos that are no longer used on ftso registry"}},{"method":"setFtsoAsset","natSpec":{"return":[],"notice":"Set asset for FTSO"}},{"method":"setFtsoAssetFtsos","natSpec":{"return":[],"notice":"Set asset FTSOs for FTSO - all ftsos should already be managed by this ftso manager"}},{"method":"setFallbackMode","natSpec":{"return":[],"notice":"Set fallback mode"}},{"method":"setFtsoFallbackMode","natSpec":{"return":[],"notice":"Set fallback mode for ftso"}},{"method":"setGovernanceParameters","natSpec":{"return":[],"notice":"Sets governance parameters for FTSOs"}},{"method":"getCurrentPriceEpochData","natSpec":{"return":[],"dec":"half-closed intervals - end time not included"}},{"method":"getRewardEpochVotePowerBlock","natSpec":{"return":[],"notice":"Gets vote power block of the specified reward epoch","param":{"_rewardEpoch":"Reward epoch sequence number"}}},{"method":"getRewardEpochToExpireNext","natSpec":{"return":[["Reward"," epoch id that will expire next"]],"notice":"Return reward epoch that will expire, when new reward epoch is initialized"}},{"method":"getGovernanceParameters","natSpec":{"return":[],"notice":"Gets governance parameters for FTSOs"}},{"method":"getCurrentRewardEpoch","natSpec":{"return":[],"notice":"Returns current reward epoch index (one currently running)"}},{"method":"getContractName","natSpec":{"return":[],"notice":"Implement this function for updating daemonized contracts through AddressUpdater."}},{"method":"getRewardEpochData","natSpec":{"return":[],"notice":"Returns reward epoch data","param":{"_rewardEpochId":"Reward epoch id"}}},{"method":"_initializeFirstRewardEpoch","natSpec":{"return":[],"notice":"Initializes first reward epoch. Also sets vote power block to FTSOs"}},{"method":"_finalizeRewardEpoch","natSpec":{"return":[],"notice":"Finalizes reward epoch"}},{"method":"_closeExpiredRewardEpochs","natSpec":{"return":[],"notice":"Closes expired reward epochs"}},{"method":"_cleanupOnRewardEpochFinalization","natSpec":{"return":[],"notice":"Performs any cleanup needed immediately after a reward epoch is finalized"}},{"method":"_finalizePriceEpoch","natSpec":{"return":[],"notice":"Finalizes price epoch"}},{"method":"_initializeCurrentEpochFTSOStatesForReveal","natSpec":{"return":[],"notice":"Initializes epoch states in FTSOs for reveal. \nPrior to initialization it sets governance parameters, if \ngovernance has changed them. It also sets price submitter trusted addresses."}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method."}},{"method":"_getCurrentRewardEpochId","natSpec":{"return":[],"notice":"Returns current reward epoch id without additional checks"}},{"method":"_getRewardEpoch","natSpec":{"return":[]}},{"method":"_getPriceEpochRevealEndTime","natSpec":{"return":[],"notice":"Returns price epoch reveal end time.","param":{"_priceEpochId":"The price epoch id."},"dec":"half-closed interval - end time not included"}},{"method":"_getPriceEpochEndTime","natSpec":{"return":[],"notice":"Returns price epoch end time.","param":{"_forPriceEpochId":"The price epoch id of the end time to fetch."},"dec":"half-closed interval - end time not included"}},{"method":"_getCurrentPriceEpochId","natSpec":{"return":[],"notice":"Returns current price epoch id. The calculation in this function\nshould fully match to definition of current epoch id in FTSO contracts."}}],"StateConnector":[],"PriceSubmitter":[{"method":"setAddressUpdater","natSpec":{"return":[],"notice":"Sets the address udpater contract.","param":{"_addressUpdater":"The address updater contract."}}},{"method":"setTrustedAddresses","natSpec":{"return":[]}},{"method":"voterWhitelisted","natSpec":{"return":[]}},{"method":"votersRemovedFromWhitelist","natSpec":{"return":[]}},{"method":"submitHash","natSpec":{"return":[],"notice":"Emits HashSubmitted event","param":{"_hash":"Hash of ftso indices, prices, random number and voter address"}}},{"method":"revealPrices","natSpec":{"return":[],"notice":"Emits PricesRevealed event","param":{"_random":"Submitted random number"}}},{"method":"getCurrentRandom","natSpec":{"return":[["Random"," number"]],"notice":"Returns current random number","dec":"Should never revert"}},{"method":"getRandom","natSpec":{"return":[["Random"," number"]],"notice":"Returns random number of the specified epoch","param":{"_epochId":"Id of the epoch"}}},{"method":"voterWhitelistBitmap","natSpec":{"return":[]}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method.","dec":"If replacing the registry or the whitelist and the old one is not empty, make sure to replicate the state,\notherwise internal whitelist bitmaps won't match."}}],"Supply":[{"method":"updateCirculatingSupply","natSpec":{"return":[],"notice":"Updates circulating supply","dec":"Also updates the burn address amount"}},{"method":"updateAuthorizedInflationAndCirculatingSupply","natSpec":{"return":[],"notice":"Updates authorized inflation and circulating supply - emits event if error","param":{"_inflationAuthorizedWei":"Authorized inflation"},"dec":"Also updates the burn address amount"}},{"method":"addTokenPool","natSpec":{"return":[],"notice":"Adds token pool so it can call updateTokenPoolDistributedAmount method when \n   some tokens are distributed","param":{"_increaseDistributedSupplyByAmountWei":"If token pool was given initial supply from excluded supply, \n   increase distributed value by this amount"}}},{"method":"increaseDistributedSupply","natSpec":{"return":[],"notice":"Increase distributed supply when excluded funds are released to a token pool or team members","param":{"_amountWei":"Amount to increase by"}}},{"method":"decreaseDistributedSupply","natSpec":{"return":[],"notice":"Descrease distributed supply if excluded funds are no longer locked to a token pool","param":{"_amountWei":"Amount to decrease by"}}},{"method":"getCirculatingSupplyAtCached","natSpec":{"return":[["_circulatingSupplyWei"," Return approximate circulating supply for last known block <= _blockNumber"]],"notice":"Get approximate circulating supply for given block number from cache - only past block","param":{"_blockNumber":"Block number"}}},{"method":"getCirculatingSupplyAt","natSpec":{"return":[["_circulatingSupplyWei"," Return approximate circulating supply for last known block <= _blockNumber"]],"notice":"Get approximate circulating supply for given block number","param":{"_blockNumber":"Block number"}}},{"method":"getInflatableBalance","natSpec":{"return":[["_inflatableBalanceWei"," Return inflatable balance"]],"notice":"Get total inflatable balance (initial genesis amount + total claimed - total excluded/locked amount)"}},{"method":"burnAddress","natSpec":{"return":[]}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method."}}],"Inflation":[{"method":"getTotals","natSpec":{"return":[["_totalAuthorizedInflationWei"," Total inflation authorized to be mintable"],["_totalInflationTopupRequestedWei"," Total inflation requested to be topped up for rewarding"],["_totalInflationTopupReceivedWei"," Total inflation received for funding reward services"],["_totalInflationTopupWithdrawnWei"," Total inflation used for funding reward services"],["_totalRecognizedInflationWei"," Total inflation recognized for rewarding"],["_totalSelfDestructReceivedWei"," Total balance received as a self-destruct recipient"]],"notice":"Get a tuple of totals across inflation annums."}},{"method":"getAnnum","natSpec":{"return":[["The"," inflation annum state."]],"notice":"Given an index, return the annum at that index.","param":{"_index":"The index of the annum to fetch."},"dec":"Expect library to revert if index not found."}},{"method":"getCurrentAnnum","natSpec":{"return":[["The"," inflation annum state of the current annum."]],"notice":"Return the current annum.","dec":"Expect library to revert if there is no current annum."}},{"method":"receiveMinting","natSpec":{"return":[],"notice":"Receive newly minted native tokens from the FlareDaemon.","dec":"Assume that the amount received will be >= last topup requested across all services.\n  If there is not enough balance sent to cover the topup request, expect library method will revert.\n  Also assume that any balance received greater than the topup request calculated\n  came from self-destructor sending a balance to this contract."}},{"method":"setTopupConfiguration","natSpec":{"return":[],"notice":"Set the topup configuration for a reward service.","param":{"_topupFactorX100":"If _topupType == FACTOROFDAILYAUTHORIZED, then this factor (times 100)\n                         is multipled by last daily authorized inflation to obtain the"},"dec":"Topup factor, if _topupType == FACTOROFDAILYAUTHORIZED, must be greater than 100."}},{"method":"getTopupConfiguration","natSpec":{"return":[["_topupConfiguration"," The configurartion of how the topup requests are calculated for a given\n                         reward service."]],"notice":"Given an inflation receiver, get the topup configuration.","param":{"_inflationReceiver":"The reward service."}}},{"method":"daemonize","natSpec":{"return":[],"notice":"Pulsed by the FlareDaemon to trigger timing-based events for the inflation process.","dec":"There are two events:\n  1) an annual event to recognize inflation for a new annum\n  2) a daily event to:\na) authorize mintable inflation for rewarding"}},{"method":"getContractName","natSpec":{"return":[],"notice":"Implement this function for updating daemonized contracts through AddressUpdater."}},{"method":"getNextExpectedTopupTs ","natSpec":{"return":[],"notice":"Returns next expected inflation topup time stamp which is also inflation authorization time. \nThe returned time from this API is actually the time of the block in which the topup is requested."}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Set a reference to a provider of the annual inflation percentage.","dec":"Assume that referencing contract has reasonablness limitations on percentages."}},{"method":"getExpectedBalance","natSpec":{"return":[],"notice":"Compute the expected balance of this contract.","param":{"_balanceExpectedWei":"The computed balance expected."}}}],"InflationAllocation":[{"method":"setSharingPercentages","natSpec":{"return":[],"notice":"Set the sharing percentages between inflation receiver contracts. Percentages must sum\n  to 100%.","param":{"_percentagePerReceiverBips":"An array of sharing percentages in bips."}}},{"method":"setAnnualInflation","natSpec":{"return":[],"notice":"Set the annual inflation percentage schedule. This schedule is meant to be set for recognition\n  a per-annum basis.","param":{"_annualInflationScheduleBips":"An array of inflation percentages in bips."},"dec":"The schedule must be a decaying schedule. Once the schedule has been used up, the last percentage\n  yielded will be the percentage that will continue to be yielded."}},{"method":"getAnnualPercentageBips","natSpec":{"return":[["The"," annual inflation percentage."]],"notice":"Get the next annual inflation percentage from the schedule and pop it off the schedule.\n  If there are no percentages remaining within the schedule, yield the last percentage known.","dec":"Note that it is up to the caller to call this function at the appropriate annum interval."}},{"method":"getSharingPercentages","natSpec":{"return":[["_sharingPercentages"," An array of SharingPercentage."]],"notice":"Get the inflation receiver contracts and the current sharing percentages."}},{"method":"_setSharingPercentages","natSpec":{"return":[],"notice":"Set the sharing percentages between inflation receiver contracts. Percentages must sum\n  to 100%.","param":{"_percentagePerReceiverBips":"An array of sharing percentages in bips."}}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method - updates Inflation \nand inflation receivers contracts."}},{"method":"_setAnnualInflationSchedule","natSpec":{"return":[],"notice":"Set the annual inflation percentage schedule. This schedule is meant to be set for recognition\n  a per-annum basis.","param":{"_annualInflationScheduleBips":"An array of inflation percentages in bips."},"dec":"The schedule must be a decaying schedule. Once the schedule has been used up, the last percentage\n  yielded will be the percentage that will continue to be yielded."}}],"DelegationAccountManager":[{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method."}}],"WNat":[{"method":"withdrawFrom","natSpec":{"return":[],"notice":"Withdraw WNAT from an owner and send native tokens to msg.sender given an allowance.","param":{"amount":"The amount to spend.\n\nRequirements:\n\n- `owner` must have a balance of at least `amount`.\n- the caller must have allowance for `owners`'s tokens of at least\n`amount`."}}},{"method":"depositTo","natSpec":{"return":[],"notice":"Deposit Native from msg.sender and mints WNAT ERC20 to recipient address.","param":{"recipient":"An address to receive minted WNAT."}}},{"method":"deposit","natSpec":{"return":[],"notice":"Deposit Native and mint wNat ERC20."}},{"method":"withdraw","natSpec":{"return":[],"notice":"Withdraw Native and burn WNAT ERC20.","param":{"amount":"The amount to withdraw."}}}],"IncentivePoolAllocation":[{"method":"setSharingPercentages","natSpec":{"return":[],"notice":"Set the sharing percentages between incentivePool receiver contracts. Percentages must sum\n  to 100%.","param":{"_percentagePerReceiverBips":"An array of sharing percentages in bips."}}},{"method":"setAnnualIncentivePool","natSpec":{"return":[],"notice":"Set the annual incentivePool percentage schedule. This schedule is meant to be set for recognition\n  a per-annum basis.","param":{"_annualIncentivePoolScheduleBips":"An array of incentivePool percentages in bips."},"dec":"Once the schedule has been used up, the last percentage\n  yielded will be the percentage that will continue to be yielded."}},{"method":"getAnnualPercentageBips","natSpec":{"return":[["The"," annual incentivePool percentage."]],"notice":"Get the next annual incentivePool percentage from the schedule and pop it off the schedule.\n  If there are no percentages remaining within the schedule, yield the last percentage known.","dec":"Note that it is up to the caller to call this function at the appropriate annum interval."}},{"method":"getSharingPercentages","natSpec":{"return":[["_sharingPercentages"," An array of SharingPercentage."]],"notice":"Get the incentivePool receiver contracts and the current sharing percentages."}},{"method":"_setSharingPercentages","natSpec":{"return":[],"notice":"Set the sharing percentages between incentivePool receiver contracts. Percentages must sum\n  to 100%.","param":{"_percentagePerReceiverBips":"An array of sharing percentages in bips."}}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method - updates IncentivePool \nand incentivePool receivers contracts."}},{"method":"_setAnnualIncentivePoolSchedule","natSpec":{"return":[],"notice":"Set the annual incentivePool percentage schedule. This schedule is meant to be set for recognition\n  a per-annum basis.","param":{"_annualIncentivePoolScheduleBips":"An array of incentivePool percentages in bips."},"dec":"Once the schedule has been used up, the last percentage\n  yielded will be the percentage that will continue to be yielded."}}],"IncentivePool":[{"method":"getTokenPoolSupplyData","natSpec":{"return":[["_lockedFundsWei"," Funds that are intentionally locked in the token pool \nand not part of circulating supply"],["_totalInflationAuthorizedWei"," Total inflation authorized amount (wei)"],["_totalClaimedWei"," Total claimed amount (wei)"]],"notice":"Return token pool supply data"}},{"method":"getTotals","natSpec":{"return":[["_totalAuthorizedIncentiveWei"," Total authorized incentive"],["_totalIncentiveTopupRequestedWei"," Total incentive requested to be topped up for rewarding"],["_totalIncentiveTopupReceivedWei"," Total incentive received for funding reward services"],["_totalIncentiveTopupWithdrawnWei"," Total incentive used for funding reward services"],["_totalRecognizedIncentiveWei"," Total incentive recognized for rewarding"]],"notice":"Get a tuple of totals across incentivePool annums."}},{"method":"getAnnum","natSpec":{"return":[["The"," incentivePool annum state."]],"notice":"Given an index, return the annum at that index.","param":{"_index":"The index of the annum to fetch."},"dec":"Expect library to revert if index not found."}},{"method":"getCurrentAnnum","natSpec":{"return":[["The"," incentivePool annum state of the current annum."]],"notice":"Return the current annum.","dec":"Expect library to revert if there is no current annum."}},{"method":"setTopupConfiguration","natSpec":{"return":[],"notice":"Set the topup configuration for a reward service.","param":{"_topupFactorX100":"If _topupType == FACTOROFDAILYAUTHORIZED, then this factor (times 100)\n                         is multipled by last daily authorized incentive to obtain the"},"dec":"Topup factor, if _topupType == FACTOROFDAILYAUTHORIZED, must be > 100 and <= 400."}},{"method":"getTopupConfiguration","natSpec":{"return":[["_topupConfiguration"," The configurartion of how the topup requests are calculated for a given\n                         reward service."]],"notice":"Given an incentivePool receiver, get the topup configuration.","param":{"_incentivePoolReceiver":"The reward service."}}},{"method":"daemonize","natSpec":{"return":[],"notice":"Pulsed by the FlareDaemon to trigger timing-based events for the incentive process.","dec":"There are two events:\n  1) an annual event to recognize incentive for a new annum\n  2) a daily event to:\na) authorize incentive for rewarding"}},{"method":"getContractName","natSpec":{"return":[],"notice":"Implement this function for updating daemonized contracts through AddressUpdater."}},{"method":"getNextExpectedTopupTs","natSpec":{"return":[],"notice":"Returns next expected incentive topup timestamp which is also incentive authorization time. \nThe returned time from this API is actually the time of the block in which the topup is requested."}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Set a reference to a provider of the annual incentivePool percentage.","dec":"Assume that referencing contract has reasonablness limitations on percentages."}}],"FtsoRewardManager":[{"method":"claimReward","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"This function is intended to be used to claim rewards in case of delegation by percentage.","param":{"_rewardEpochs":"array of reward epoch numbers to claim for"},"dec":"Reverts if `msg.sender` is delegating by amount"}},{"method":"claimAndWrapReward","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"This function is intended to be used to claim and wrap rewards in case of delegation by percentage.","param":{"_rewardEpochs":"array of reward epoch numbers to claim for"},"dec":"Reverts if `msg.sender` is delegating by amount"}},{"method":"claimAndWrapRewardByExecutor","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\n  call, we allow the owner to control the timing of the calls.","param":{"_rewardEpochs":"array of reward epoch numbers to claim for"},"dec":"Reverts if `msg.sender` is delegating by amount"}},{"method":"claimRewardFromDataProviders","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"This function is intended to be used to claim rewards in case of delegation by amount.","param":{"_dataProviders":"array of addresses representing data providers to claim the reward from"},"dec":"Function can be used by a percentage delegator but is more gas consuming than `claimReward`."}},{"method":"claimAndWrapRewardFromDataProviders","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"This function is intended to be used to claim and wrap rewards in case of delegation by amount.","param":{"_dataProviders":"array of addresses representing data providers to claim the reward from"},"dec":"Function can be used by a percentage delegator but is more gas consuming than `claimReward`."}},{"method":"claimAndWrapRewardFromDataProvidersByExecutor","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\n  call, we allow the owner to control the timing of the calls.","param":{"_dataProviders":"array of addresses representing data providers to claim the reward from"},"dec":"Function can be used by a percentage delegator but is more gas consuming than `claimReward`."}},{"method":"setClaimExecutors","natSpec":{"return":[],"param":{"_executors":"The new executors. All old executors will be deleted and replaced by these."}}},{"method":"setAllowedClaimRecipients","natSpec":{"return":[],"param":{"_recipients":"The new allowed recipients. All old recipients will be deleted and replaced by these."}}},{"method":"activate","natSpec":{"return":[],"notice":"Activates reward manager (allows claiming rewards)"}},{"method":"enableClaims","natSpec":{"return":[],"notice":"Enable claiming for current and all future reward epochs"}},{"method":"deactivate","natSpec":{"return":[],"notice":"Deactivates reward manager (prevents claiming rewards)"}},{"method":"accrueUnearnedRewards","natSpec":{"return":[],"notice":"Accrue unearned rewards for price epoch.","dec":"Typically done when ftso in fallback or because of insufficient vote power.\n Simply accrue them so they will not distribute and burn them later."}},{"method":"distributeRewards","natSpec":{"return":[],"notice":"Distributes rewards to data providers accounts, according to input parameters.","dec":"must be called with totalWeight > 0 and addresses.length > 0"}},{"method":"setDataProviderFeePercentage","natSpec":{"return":[["Returns"," the reward epoch number when the setting becomes effective."]],"notice":"Allows data provider to set (or update last) fee percentage.","param":{"_feePercentageBIPS":"number representing fee percentage in BIPS"}}},{"method":"setInitialRewardData","natSpec":{"return":[],"notice":"Set initial reward data values - only if oldRewardManager is set","dec":"Should be called at the time of switching to the new reward manager, can be called only once"}},{"method":"setNewFtsoRewardManager","natSpec":{"return":[],"notice":"Sets new ftso reward manager which will take over closing expired reward epochs","dec":"Should be called at the time of switching to the new reward manager, can be called only once"}},{"method":"closeExpiredRewardEpoch","natSpec":{"return":[],"notice":"Collects funds from expired reward epoch and totals.","dec":"Triggered by ftsoManager on finalization of a reward epoch.\nOperation is irreversible: when some reward epoch is closed according to current\nsettings of parameters, it cannot be reopened even if new parameters would \nallow it since nextRewardEpochToExpire in ftsoManager never decreases."}},{"method":"getEpochReward","natSpec":{"return":[["_totalReward"," number representing the total epoch reward"],["_claimedReward"," number representing the amount of total epoch reward that has been claimed"]],"notice":"Returns information on epoch reward","param":{"_rewardEpoch":"reward epoch number"}}},{"method":"getInflationAddress","natSpec":{"return":[["The"," inflation address"]],"notice":"Returns the Inflation contract address.","dec":"Inflation receivers must have a reference to Inflation in order to receive native tokens for claiming."}},{"method":"getStateOfRewards","natSpec":{"return":[["_dataProviders"," positional array of addresses representing data providers"],["_rewardAmounts"," positional array of reward amounts"],["_claimed"," positional array of boolean values indicating if reward is claimed"],["_claimable"," boolean value indicating if rewards are claimable"]],"notice":"Returns the state of rewards for `_beneficiary` at `_rewardEpoch`","param":{"_rewardEpoch":"reward epoch number"},"dec":"Reverts when queried with `_beneficary` delegating by amount"}},{"method":"getStateOfRewardsFromDataProviders","natSpec":{"return":[["_rewardAmounts"," positional array of reward amounts"],["_claimed"," positional array of boolean values indicating if reward is claimed"],["_claimable"," boolean value indicating if rewards are claimable"]],"notice":"Returns the state of rewards for `_beneficiary` at `_rewardEpoch` from `_dataProviders`","param":{"_dataProviders":"positional array of addresses representing data providers"}}},{"method":"getEpochsWithClaimableRewards","natSpec":{"return":[["_startEpochId"," the oldest epoch id that allows reward claiming"],["_endEpochId"," the newest epoch id that allows reward claiming"]],"notice":"Returns the start and the end of the reward epoch range for which the reward is claimable"}},{"method":"getEpochsWithUnclaimedRewards","natSpec":{"return":[["_epochIds"," array of epoch ids"]],"notice":"Returns the array of claimable epoch ids for which the reward has not yet been claimed","param":{"_beneficiary":"address of reward beneficiary"},"dec":"Reverts when queried with `_beneficary` delegating by amount"}},{"method":"getUnclaimedReward","natSpec":{"return":[["_amount"," number representing the unclaimed amount"],["_weight"," number representing the share that has not yet been claimed"]],"notice":"Returns the information on unclaimed reward of `_dataProvider` for `_rewardEpoch`","param":{"_dataProvider":"address representing the data provider"}}},{"method":"getDataProviderPerformanceInfo","natSpec":{"return":[["_rewardAmount"," number representing the amount of rewards"],["_votePowerIgnoringRevocation"," number representing the vote power ignoring revocations"]],"notice":"Returns the information on rewards and initial vote power of `_dataProvider` for `_rewardEpoch`","param":{"_dataProvider":"address representing the data provider"}}},{"method":"getClaimedReward","natSpec":{"return":[["_claimed"," boolean indicating if reward has been claimed"],["_amount"," number representing the claimed amount"]],"notice":"Returns the information on claimed reward of `_dataProvider` for `_rewardEpoch` by `_claimer`","param":{"_claimer":"address representing the claimer"}}},{"method":"getDataProviderCurrentFeePercentage","natSpec":{"return":[],"notice":"Returns the current fee percentage of `_dataProvider`","param":{"_dataProvider":"address representing data provider"}}},{"method":"getDataProviderFeePercentage","natSpec":{"return":[],"notice":"Returns the fee percentage of `_dataProvider` at `_rewardEpoch`","param":{"_rewardEpoch":"reward epoch number"}}},{"method":"getDataProviderScheduledFeePercentageChanges","natSpec":{"return":[["_feePercentageBIPS"," positional array of fee percentages in BIPS"],["_validFromEpoch"," positional array of block numbers the fee setings are effective from"],["_fixed"," positional array of boolean values indicating if settings are subjected to change"]],"notice":"Returns the scheduled fee percentage changes of `_dataProvider`","param":{"_dataProvider":"address representing data provider"}}},{"method":"getRewardEpochToExpireNext","natSpec":{"return":[["Reward"," epoch id that will expire next"]],"notice":"Return reward epoch that will expire, when new reward epoch is initialized"}},{"method":"getTokenPoolSupplyData","natSpec":{"return":[["_lockedFundsWei"," Foundation locked funds (wei)"],["_totalInflationAuthorizedWei"," Total inflation authorized amount (wei)"],["_totalClaimedWei"," Total claimed amount (wei)"]],"notice":"Return token pool supply data"}},{"method":"claimExecutors","natSpec":{"return":[]}},{"method":"allowedClaimRecipients","natSpec":{"return":[]}},{"method":"getContractName","natSpec":{"return":[],"notice":"Implement this function for updating inflation receiver contracts through AddressUpdater."}},{"method":"getRewardEpochVotePowerBlock","natSpec":{"return":[],"notice":"Return reward epoch vote power block","param":{"_rewardEpoch":"reward epoch number"}}},{"method":"getCurrentRewardEpoch","natSpec":{"return":[],"notice":"Return current reward epoch number"}},{"method":"getInitialRewardEpoch","natSpec":{"return":[["_initialRewardEpoch"," initial reward epoch number"]],"notice":"Return initial reward epoch number"}},{"method":"_burnUnearnedRewards","natSpec":{"return":[],"notice":"Burn rewards if there are any pending to burn, up to the maximum allowable.","dec":"This is meant to be called once per day, right after inflation is received.\n There is a max allowable pct to burn so that the contract does not run out"}},{"method":"_claimOrWrapReward","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"This function is intended to be used to claim rewards in case of delegation by percentage.","param":{"_rewardEpochs":"array of reward epoch numbers to claim for"},"dec":"Reverts if `msg.sender` is delegating by amount"}},{"method":"_claimOrWrapRewardFromDataProviders","natSpec":{"return":[["_rewardAmount"," amount of total claimed rewards"]],"notice":"This function is intended to be used to claim rewards in case of delegation by amount.","param":{"_wrap":"should reward be wrapped immediatelly"},"dec":"Function can be used by a percentage delegator but is more gas consuming than `claimReward`."}},{"method":"_claimReward","natSpec":{"return":[["Returns"," the total reward amount."]],"notice":"Claims `_rewardAmounts` for `_dataProviders`.","dec":"Internal function that takes care of reward bookkeeping","param":{"_rewardState":"object holding reward state"}}},{"method":"_transferReward","natSpec":{"return":[],"notice":"Transfers `_rewardAmount` to `_recipient`.","param":{"_rewardAmount":"number representing the amount to transfer"},"dec":"Uses low level call to transfer funds."}},{"method":"_sendWrappedRewardTo","natSpec":{"return":[],"notice":"Wrap (deposit) `_rewardAmount` to `_recipient` on WNat.","param":{"_rewardAmount":"number representing the amount to transfer"}}},{"method":"_updateContractAddresses","natSpec":{"return":[],"notice":"Implementation of the AddressUpdatable abstract method."}},{"method":"_getTotalPriceEpochRewardWei","natSpec":{"return":[["Price"," epoch reward in wei"]],"notice":"Returns the reward to distribute for a given price epoch.","param":{"_priceEpochEndTime":"Datetime stamp of the end of the price epoch"},"dec":"Based on a daily distribution and period."}},{"method":"_getStateOfRewards","natSpec":{"return":[["_rewardState"," object holding reward state"]],"notice":"Returns the state of rewards for `_beneficiary` at `_rewardEpoch`.","dec":"Reverts when queried with `_beneficary` delegating by amount.","param":{"_zeroForClaimed":"boolean value that enables skipping amount computation for claimed rewards"}}},{"method":"_getStateOfRewardsFromDataProviders","natSpec":{"return":[["_rewardState"," object holding reward state"]],"notice":"Returns the state of rewards for `_beneficiary` at `_rewardEpoch` from `_dataProviders`","param":{"_zeroForClaimed":"boolean value that enables skipping amount computation for claimed rewards"}}},{"method":"_isRewardClaimable","natSpec":{"return":[],"notice":"Reports if rewards for `_rewardEpoch` are claimable.","param":{"_currentRewardEpoch":"number of the current reward epoch"}}},{"method":"_getEpochsWithClaimableRewards","natSpec":{"return":[["_startEpochId"," the oldest epoch id that allows reward claiming"],["_endEpochId"," the newest epoch id that allows reward claiming"]],"notice":"Returns the start and the end of the reward epoch range for which the reward is claimable"}},{"method":"_isRewardClaimed","natSpec":{"return":[],"notice":"Reports if reward at `_rewardEpoch` for `_dataProvider` has already been claimed by `_claimer`.","param":{"_claimer":"address representing a reward claimer"}}},{"method":"_getClaimedReward","natSpec":{"return":[],"notice":"Returns the reward amount at `_rewardEpoch` for `_dataProvider` claimed by `_claimer`.","param":{"_claimer":"address representing a reward claimer"}}},{"method":"_getRewardAmount","natSpec":{"return":[],"notice":"Returns the reward amount for `_dataProvider` at `_rewardEpoch`","param":{"_rewardWeight":"number representing reward weight"}}},{"method":"_getRewardWeightForDataProvider","natSpec":{"return":[],"notice":"Returns reward weight for `_dataProvider` at `_rewardEpoch`","param":{"_votePowerBlock":"block number used to determine the vote power for reward computation"}}},{"method":"_getRewardWeightForDelegator","natSpec":{"return":[],"notice":"Returns reward weight at `_rewardEpoch` for delegator delegating `_delegatedVotePower` to `_delegate`.","param":{"_rewardEpoch":"reward epoch number"}}}]}